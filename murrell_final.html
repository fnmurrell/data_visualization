<!DOCTYPE html>
<html>
<head>
	<title>Final Project | Most Streamed Songs of 2024</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
	<style>
    	text { 
			font-family: Arial; 
			font-size: 15px;
		}
		.axis path, .axis line {
			fill: none;
			stroke: black;
			shape-rendering: crispEdges;
		}
		.tick text {
			fill: black;
			font-size: 11px;
		}

		rect {
			stroke: white;
		}
	</style>
</head>
<body>

	<svg id="main" width="60%" height="600">
		<text id='label' x='20' y='20'>10 Most Streamed Songs of 2024</text>
		<g transform="translate(20,40)"></g>
	</svg>

	<svg id="additional" width="40%" height="600"></svg>
		<text id='label' x='20' y='20'>Song Information</text>
		<g transform="translate(20,40)"></g>
		</svg>

    <script>
		var CHART_WIDTH = 500;
		var CHART_HEIGHT = 500;
		var PADDING = 15;

		var energyProduction = [];

		function drawLineChart() {
			var maxValue = d3.max(energyProduction, function(d) {
				return d.production;
			});
			
			var xScale = d3.scale.linear();
			var yScale = d3.scale.linear();

			xScale.domain(['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sept','Oct']).range([PADDING, CHART_WIDTH - PADDING * 2]); 
			// domain should default to all months and then be filtereable
			
			yScale.domain([0, 90]).range([CHART_HEIGHT - PADDING, PADDING]);  
			// domain will need to fluctuate based on streaming number 

			var pathGenerator = d3.svg.line()
				.x(function(d) { return xScale(d.year);}) // sets the x coordinate
				.y(function(d) { return yScale(d.production);});  // sets the y coordinate

			var g = d3.select('svg').select('g');

			var xAxis = d3.svg.axis()
    			.scale(xScale)
    			.orient('bottom')
    			.tickFormat(function(d) { return "" + d; });
				// draw the x axis at the bottom of the chart

    		var yAxis = d3.svg.axis()
    			.scale(yScale)
    			.orient('left');
				// draw the y axis on the left-hand side of the chart

    		g.append('g')
    			.attr('class','axis')
    			.attr('transform','translate(0,' + CHART_HEIGHT + ')')
    			.call(xAxis);

    		g.append('g')
    			.attr('class','axis')
    			.call(yAxis);

    		g.append('path')
    			.style('fill','none')
    			.style('stroke','steelblue')
    			.style('stroke-width','3px')
    			.attr('d', pathGenerator(energyProduction));
				// define the style of the line. Will need to choose 10 colors that are assigned in a specific order. 
        }

		d3.csv('most_streamed_2024.csv', function(data)
		{
			// remove code and define new functions 
			// for each month, grab the total streams for a song; add streams over each month for the same song 
				// compare total streams to find the top 10 for the year and display 
				// same logic would apply for a month range 

			var record = data[0];  // loop through all years, from 1980 to 2012
			for (var y=1980; y<=2012; y++) 
			{
				var value = record[y];

				var object = {
					year: y,
					production: +value
				};
				energyProduction.push(object);
			}
			drawLineChart();
		});
		
		// define three event listeners 
			// streaming service filter
			// month filter
			// artist filter 
		// define a hover effect that does not change color but makes the line bolder or something? 				
		d3.selectAll().on("click", function() 
			{
				//New values for dataset
				dataset = [ 11, 12, 15, 20, 18, 17, 16, 18, 23, 25,5, 10, 13, 19, 21, 25, 22, 18, 15, 13 ];

				//Update all rects
				svg.selectAll("rect")
					.data(dataset)
					.transition()
					.duration(1000)								// <-- Controlled duration, 1000ms = 1s
					.attr("y", function(d) {
					   	return h - yScale(d);
					})
					.attr("height", function(d) {
					   	return yScale(d);
					})
					.attr("fill", function(d) {
						return "rgb(0, 0, " + Math.round(d * 10) + ")";
					});

				//Update all labels
				svg.selectAll("text")
					.data(dataset)
					.text(function(d) {
					   	return d;
					})
					.attr("x", function(d, i) {
					   	return xScale(i) + xScale.bandwidth() / 2;
					})
					.attr("y", function(d) {
					   	return h - yScale(d) + 14;
					});
					   				
			});


		let filters = [
			{key:'Overall court grouping',value:''},
			{key:'Borough',value:''},
			{key:'Name',value:''}
		function findActiveFilters() 
		{
			return filters.filter(d => d.value);
		}
		function runFilter(arr,filter)
		{
			return arr.filter( d => {
				return d[filter.key] == filter.value
			})
		}
		function filterData() 
		{
			let filteredData = [];
			let activeFilters = findActiveFilters();
			activeFilters.forEach(d => {
				if (filteredData.length == 0) {
					filteredData = runFilter(allData, d);
				} 
				else {
					filteredData = runFilter(filteredData, d);
				}
			});
				return filteredData;
			}
	</script>
</body>
</html>